\subsection{Game Architecture in Modern
MMORPG's}\label{game-architecture-in-modern-mmorpgs}

The architecture of modern online games---especially Massively
Multiplayer Online Role-Playing Games (MMORPGs)---is the product of
decades of iteration in distributed systems, networked simulation, and
real-time rendering. These games must simultaneously satisfy low-latency
interactivity, security and fairness, and horizontal
scalability---requirements that often conflict with one another
{[}@Assiotis2010{]}. The industry-standard solution is a
server-authoritative, hybrid client-server model, which strategically
splits responsibility across multiple layers while maintaining a single
``source of truth'' for all game state.

At a high level, this architecture can be divided into three
interconnected layers:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Game Client -- the local software running on the player's device. It
  handles real-time input capture, rendering, audio processing, and UI
  logic.
\item
  Game Server -- the authoritative system that executes validated player
  actions, simulates world state, and broadcasts synchronized updates to
  connected clients.
\item
  Database Layer -- a persistent storage system that retains critical
  state between sessions, including player data, inventories,
  progression, and economic information.
\end{enumerate}

By distributing functionality in this way, the system maximizes
performance and maintainability. The server-authoritative design ensures
consistency and fairness, while predictive client-side rendering ensures
responsiveness.

The Database Layer, typically built on top of SQL databases, holds the
entire system's data persistence. The use of relational databases is
motivated by the ACID (Atomicity, Consistency, Isolation, Durability)
guarantees, which are crucial for ensuring that in-game
transactions---such as trading items or spending currency---are either
fully completed or not executed at all, thereby preventing issues such
as item duplication or inconsistent state.

\subsubsection{Server-Authoritative Logic and Client
Responsibilities}\label{server-authoritative-logic-and-client-responsibilities}

In this model, the Game Server is the source of truth. It manages the
shared simulation of the world---tracking positions, combat states,
cooldowns, inventories, and interactions. The client acts as a
high-performance visualization layer: it renders what the server has
confirmed to be true, rather than deciding game outcomes itself.

When a player issues an input (e.g., ``move forward'' or ``attack
monster''), the client sends an intent message to the server. The server
validates the request---checking whether the player is alive, within
range, or meets any conditions---then executes the result and sends a
new authoritative snapshot back to all relevant clients.

This pattern prevents cheating. Since the client never dictates game
logic, it cannot forge outcomes like teleporting, duplicating items, or
bypassing cooldowns. The server simply ignores any invalid or impossible
requests. As a result, client-side modifications or ``hacks'' have no
impact on the true game state, reinforcing both security and fairness.

\subsubsection{Unity Ecosystem}\label{unity-ecosystem}

The Unity engine has become one of the most prevalent tools for building
MMORPG clients, thanks to its mature ecosystem, cross-platform
deployment, and extensive developer community. It abstracts away the
deep technical challenges of 3D rendering, animation, audio, and physics
simulation, allowing developers to focus on gameplay logic.

Unity's scripting layer is built entirely in C\#, which offers a balance
of performance, safety, and productivity {[}@unity2025scripting{]}. The
engine's component-based architecture allows developers to compose
complex \texttt{GameObjects} out of small, reusable C\# scripts, each
encapsulating specific behavior. This modularity enables maintainable
and scalable client logic---a crucial property for games that evolve
over years of live service.

For multiplayer communication, Unity provides Netcode for
\texttt{GameObjects}, an official high-level networking solution that
simplifies synchronization between the server and multiple clients
{[}@unity2025netcode{]}. Alternatively, community-driven solutions like
Mirror remain popular for their flexibility, maturity, and open-source
nature {[}@mirror2025networking{]}. ForRegardless of the networking
library, the client's responsibilities remain consistent:

\begin{itemize}
\tightlist
\item
  Transmit player intent to the server (e.g., movement, abilities,
  interactions).
\item
  Receive and interpolate server updates to display smooth, continuous
  movement.
\item
  Predict local actions (like immediate movement or attacks) while
  waiting for confirmation to minimize perceived latency.
\end{itemize}

A key architectural and development advantage in Unity is the ability to
use a single, shared codebase for both the client and the server. When
building for a dedicated game server, developers compile a ``headless''
build. This is a version of the application stripped of all client-side
components---it has no graphics, audio, or user interface.

This headless server runs only the core game logic, physics, and
networking, acting as the single source of truth (or ``authority'') for
the game. This approach is highly efficient, as the server doesn't waste
resources rendering visuals, significantly reducing hosting costs and
complexity. Developers use conditional logic to differentiate between
authoritative server code and client-side presentation code, all within
the same project.

\subsubsection{Aspnet Server and
Database}\label{aspnet-server-and-database}

The server and database layer form the logical and infrastructural
backbone of the MMORPG. In modern cross-platform development, ASP.NET
Core stands out as a robust, high-performance framework for building
scalable, asynchronous backends {[}@microsoft2025aspnet{]}. Its major
advantage for Unity-based games is the shared C\# language, which allows
both client and server to use identical data models---ensuring
serialization consistency and eliminating redundancy.

ASP.NET Core supports multiple communication paradigms:

\begin{itemize}
\tightlist
\item
  REST or gRPC APIs for transactional or asynchronous actions (e.g.,
  login, character selection, trading).
\item
  SignalR for event-driven, real-time updates like chat or notifications
  {[}@microsoft2025signalr{]}.
\item
  Custom socket servers (TCP/UDP) for the most latency-sensitive systems
  such as combat, physics, and positional updates.
\end{itemize}

\begin{quote}
Note: While ASP.NET Core can be used for custom socket servers, this
approach is often prohibitively time-consuming. It forces the developer
to implement their entire game server logic from the ground up. For this
reason, it is far more common to use dedicated game networking libraries
like Netcode or Mirror, which handle most of this complexity out of the
box.
\end{quote}

For persistence, developers commonly integrate Entity Framework Core (EF
Core), a mature Object-Relational Mapper (ORM) that translates
high-level C\# LINQ queries into optimized SQL
{[}@microsoft2025efcore{]}. Combined with relational databases like
PostgreSQL or SQL Server, this ensures transactional integrity for
complex operations such as trades or auctions, where partial success
could otherwise corrupt the economy.

\subsubsection{Networking
Considerations}\label{networking-considerations}

The biggest technical challenge in MMORPG networking is latency (time
delay between player input and server acknowledgment). Since a single
internet round-trip often takes tens or hundreds of milliseconds, it's
impossible to synchronously query the server for every frame (rendered
every 16 ms at 60 FPS).

Thus, modern clients operate on a partial, predictive local copy of the
game world. The player's own actions are executed immediately for
responsiveness, while other players' movements are interpolated or
extrapolated based on previous server updates. When the authoritative
state arrives, the client reconciles any differences---adjusting
positions, animations, or states to match the server's truth.

Three primary options:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Remote Rendering (Cloud Gaming) -- all simulation and rendering occur
  on a server, with clients streaming video. Secure but impractical for
  MMORPGs due to bandwidth and latency limits.
\item
  Lockstep Simulation -- every client maintains a full copy of the world
  and executes deterministic commands simultaneously. Efficient for RTS
  games but too latency-sensitive and insecure for MMOs.
\item
  Hybrid Server-Authoritative Model -- the dominant approach. Clients
  predict and render locally while the server maintains the only true
  world state. This hybrid model offers the best compromise between
  security, responsiveness, and scalability, making it the cornerstone
  of modern online game design
\end{enumerate}

\subsubsection{Blockchain Integration}\label{blockchain-integration}

The integration of blockchain technology introduces complexity in how
persistence, ownership, and value are managed. Traditional MMORPG
servers are centralized, mutable, and optimized for low-latency
simulation. In contrast, blockchains are decentralized, immutable, and
optimized for security and verifiability, where transaction finality can
take seconds or minutes.

Because of these differences, real-time gameplay cannot directly depend
on blockchain transactions. The practical solution is a hybrid
off-chain/on-chain architecture, where each layer serves distinct
purposes:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Off-Chain Game Server which handles all fast, real-time
  simulation---movement, combat, physics, AI, and
  interactions---ensuring responsive gameplay.
\item
  On-Chain (Blockchain Layer) which holds and records high-value or
  permanent events, including token ownership transfers, NFT minting.
\end{enumerate}

A secure asynchronous bridge connects the two. For example, when a
player wins a rare item in-game, the server signs a cryptographic
message confirming the event and passes it to an crypto routing service.
The router then submits it to the blockchain, where a smart contract
mints the corresponding NFT to the player's wallet. Crucially, this
process is non-blocking.

This design preserves the speed and responsiveness of traditional
MMORPGs while leveraging blockchain for verifiable digital ownership,
player-driven economies, and transparent asset histories.
